<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>msa_sdk.util API documentation</title>
<meta name="description" content="Module util." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msa_sdk.util</code></h1>
</header>
<section id="section-intro">
<p>Module util.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module util.&#34;&#34;&#34;
import fcntl
import io
import os
import subprocess
import sys
import time
from configparser import ConfigParser
from datetime import datetime
from ipaddress import AddressValueError
from ipaddress import IPv4Address
from ipaddress import IPv4Network
from ipaddress import ip_network

from msa_sdk import constants
from msa_sdk.orchestration import MSA_API
from msa_sdk.orchestration import Orchestration
from msa_sdk.variables import Variables


def convert_yang_into_xml_file(yang_filenames, xml_output_file: str):
    &#34;&#34;&#34;
    Convert YANG files into one XML file.

    Parameters
    ----------
    yang_filenames: Array
            It contains the list of YANG files (with full path name of
            each files

    Returns
    -------
    xml_output_file: String
            Filename of the new YANG file

    &#34;&#34;&#34;
    # Get the directory where all PYANG files are present. We should run
    # pyang in this directory to be able to load other yang generic library
    # dependency present in the same directory.
    yang_path = os.path.dirname(yang_filenames[0])
    yang_files = &#39;&#39;
    for file in yang_filenames:
        yang_files = yang_files + &#39; &#39; + str(os.path.basename(file))

    pyang_command = &#39; cd &#34;&#39; + yang_path + \
        &#39;&#34;;  pyang -f sample-xml-skeleton &#39; + \
        &#39;--sample-xml-skeleton-doctype=config  -o &#39; + \
        xml_output_file + yang_files

    try:
        subprocess.check_output(pyang_command, shell=True,
                                stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as error_msg:
        return &#39;Error:&#39; + str(error_msg)

    return xml_output_file


def get_ip_range(start, end):
    &#34;&#34;&#34;

    Generate a list of all IP addresses between $start and $end (inclusive).

    For Ex. (1.1.1.1, 1.1.1.5) =&gt; [1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.1.4, 1.1.1.5]

    Parameters
    ----------
    start: String
            start of the range
    end: String
            end of the range

    Returns
    -------
    list: List of range of ips

    &#34;&#34;&#34;
    ip_range = list(range(int(IPv4Address(start)), int(IPv4Address(end))))
    result = list(map(lambda x: str(IPv4Address(x)), ip_range))
    result.append(end)

    return result


def cidr_to_range(cdir):
    &#34;&#34;&#34;

    Get the Start and End Address of the IP range from CIDR.

    Eg.[10.0.0.0/24] =&gt; 10.0.0.0 - 10.0.0.255

    Parameters
    ----------
    cdir: String
        cdir range

    Returns
    -------
    list: List of ip range

    &#34;&#34;&#34;
    r_ips = list(ip_network(cdir).hosts())
    ip_range = [str(x) for x in r_ips]

    return ip_range


def obtain_file_lock(lock_file_name, mode, process_param, sleep_time=60,
                     timeout=300):
    &#34;&#34;&#34;

    Obtain lock file.

    Parameters
    ----------
    lock_file_name: String
        File name
    mode: String mode
        File mode
    process_param: options PROCESSINSTANCEID, TASKID, EXECNUMBER
        Process parameters
    sleep_time: Integer
        Time to wait until next try
    timeout: Integer
        How much time (timeout * sleep_time) it will take to timeout

    Returns
    ------
    json: Result of the lock

    &#34;&#34;&#34;
    lock_file_path = &#39;{}/{}&#39;.format(constants.UBI_JENTREPRISE_DIRECTORY,
                                    lock_file_name)

    lock_obtained = False

    r_json = &#39;&#39;
    tries = 1
    while not lock_obtained and tries &lt; timeout:
        try:
            if os.path.exists(lock_file_path):
                with open(lock_file_path) as f_file:
                    file_content = f_file.read()
            else:
                f_lock_file = open(lock_file_path, mode)
                fcntl.flock(f_lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
                with open(lock_file_path, &#39;w+&#39;) as f_file:
                    f_file.write(&#39;Locked&#39;)
                lock_obtained = True
                fcntl.flock(f_lock_file, fcntl.LOCK_UN)
                continue

            if &#39;unlocked&#39; not in file_content.lower():
                raise io.BlockingIOError

            lock_obtained = True
        except io.BlockingIOError:
            tries += 1
            time.sleep(sleep_time)

    if not lock_obtained:
        r_json = MSA_API.process_content(
            constants.FAILED,
            &#39;Lock could not be obtained on the file {}&#39;.format(
                lock_file_name),
            process_param,
            True)
    else:
        r_json = MSA_API.process_content(
            constants.ENDED,
            &#39;Lock obtained on the file {}&#39;.format(lock_file_name),
            process_param,
            True)

    return r_json


def release_file_lock(lock_file_name, process_param, sleep_time=60,
                      timeout=300):
    &#34;&#34;&#34;

    Release lock file.

    Parameters
    ----------
    lock_file_name: String
        File name
    process_param: options PROCESSINSTANCEID, TASKID, EXECNUMBER
        Process parameters
    sleep_time: Integer
        Time to wait until next try
    timeout: Integer
        How much time (timeout * sleep_time) it will take to timeout

    Returns
    ------
    json: Result of the release

    &#34;&#34;&#34;
    lock_file_path = &#39;{}/{}&#39;.format(constants.UBI_JENTREPRISE_DIRECTORY,
                                    lock_file_name)

    f_lock_file = open(lock_file_path)

    r_json = &#39;&#39;
    tries = 1

    while tries &lt; timeout:
        try:
            fcntl.flock(f_lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
            with open(lock_file_path, &#39;w+&#39;) as f_file:
                f_file.write(&#39;Unlocked&#39;)
            fcntl.flock(f_lock_file, fcntl.LOCK_UN)
            break

        except io.BlockingIOError:
            tries += 1
            time.sleep(sleep_time)

    if tries &gt;= timeout:
        r_json = MSA_API.process_content(
            constants.FAILED,
            &#39;Lock could not be released on the file {}&#39;.format(
                lock_file_name), process_param, True)
    else:
        r_json = MSA_API.process_content(
            constants.ENDED,
            &#39;Lock released on the file {}&#39;.format(lock_file_name),
            process_param, True)

    return r_json


def is_overlapping_cidr(cidr1, cidr2):
    &#34;&#34;&#34;

    Check if cidr1 overlaps cidr2.

    Parameters
    ---------
    cidr1: String
        First cidr to compare
    cidr2: String
        Second cidr to compare

    Returns
    -------
    bool: Cidr overlaps

    &#34;&#34;&#34;
    return IPv4Network(cidr1).overlaps(IPv4Network(cidr2))


def address_is_in_network(addr, net):
    &#34;&#34;&#34;

    Address is in network.

    Parameters
    ----------
    addr: String
        Address - 10.0.0.20
    net: String
        Network - 10.0.0.0/24
    mask: String
        Network mask

    Returns
    -------
    Bool - Returns if the address overlaps a network

    &#34;&#34;&#34;
    return IPv4Network(addr).overlaps(IPv4Network(net))


def is_cidr(addr):
    &#34;&#34;&#34;

    Check if a valid cidr.

    Parameters
    ----------
    addr: String
        IP address

    Returns
    -------
    bool: Valid cidr

    &#34;&#34;&#34;
    try:
        IPv4Address(addr)
    except AddressValueError:
        return False

    return True


def netmask_to_cidr(netmask):
    &#34;&#34;&#34;

    Netmask to cidr.

    Parameters
    ----------
    netmask: String
        Netmask

    Returns
    -------
    string: cidr netmask

    &#34;&#34;&#34;
    return sum([bin(int(x)).count(&#34;1&#34;) for x in netmask.split(&#34;.&#34;)])


def cidr_match(ip_addr, cidr):
    &#34;&#34;&#34;

    Match cidr.

    Parameters
    ----------
    ip_addr: String
        IP Address eg: 10.1.0.20
    cidr: String
        cidr eg. 10.1.0.20/32

    Returns
    -------
    Bool

    &#34;&#34;&#34;
    subnet, mask = cidr.split(&#39;/&#39;)

    return (int(IPv4Address(ip_addr)) &amp; ~((1 &lt;&lt; (32 - int(mask))) - 1)) == \
        int(IPv4Address(subnet))


def cidr_to_subnet_and_subnetmask_address(cidr):
    &#34;&#34;&#34;

    Get the subnet and subnetmast from a cidr.

    Parameters
    ----------
    cidr: String eg. &#39;10.0.0.0/24&#39;
        cidr value

    Returns
    -------
    Dict: netmask and network_address

    &#34;&#34;&#34;
    network = IPv4Network(cidr)

    return {&#39;subnet_ip&#39;: str(network.network_address),
            &#39;subnet_mask&#39;: str(network.netmask)}


def log_to_process_file(service_id: str, log_message: str, process_id: str=None) -&gt; bool:
    &#34;&#34;&#34;

    Write log string with ISO timestamp to process log file.

    Parameters
    ----------
    service_id: String
                Service ID of current process
    log_message: String
                 Log text
    process_id: String
                Process ID of current process

    Returns
    -------
    bool:
        true:  log string has been written correctlly

        false: log string has not been written correctlly or the
                log file doesnt exist

    &#34;&#34;&#34;
    process_log_path = &#39;{}/process-{}.log&#39;.format(
        constants.PROCESS_LOGS_DIRECTORY, service_id)
    current_time = datetime.now().isoformat()
    if not process_id:
        log_string = &#39;{date}:{file}:DEBUG:{msg}\n&#39;.format(
            date=current_time, file=sys.argv[0].split(&#39;/&#39;)[-1], msg=log_message)
    else:
        log_string = &#39;{date}:{file}:|{process_id}|:DEBUG:{msg}\n&#39;.format(
            date=current_time, file=sys.argv[0].split(&#39;/&#39;)[-1], process_id=process_id, msg=log_message)
        if &#34;\n&#34; in log_message:
            log_string += &#39;{date}:{file}:|{process_id}--|\n&#39;.format(
            date=current_time, file=sys.argv[0].split(&#39;/&#39;)[-1], process_id=process_id)
    try:
        with open(process_log_path, &#39;a&#39;) as log_file:
            log_file.write(log_string)
    except IOError:
        return False

    return True


def update_asynchronous_task_details(details: str):
    &#34;&#34;&#34;

    Update Asynchronous Task details.

    Print task details during Process execution.

    Parameters
    ----------
    detail: String
            The message to display in msa-ui

    Returns
    -------
    object: Orchestration

    &#34;&#34;&#34;
    context = Variables.task_call()
    process_instance_id = context[&#39;PROCESSINSTANCEID&#39;]
    task_id = context[&#39;TASKID&#39;]
    exec_number = context[&#39;EXECNUMBER&#39;]
    orch = Orchestration(None)
    orch.update_asynchronous_task_details(process_instance_id, task_id,
                                          exec_number, details)
    return orch</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="msa_sdk.util.address_is_in_network"><code class="name flex">
<span>def <span class="ident">address_is_in_network</span></span>(<span>addr, net)</span>
</code></dt>
<dd>
<div class="desc"><p>Address is in network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>String</code></dt>
<dd>Address - 10.0.0.20</dd>
<dt><strong><code>net</code></strong> :&ensp;<code>String</code></dt>
<dd>Network - 10.0.0.0/24</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>String</code></dt>
<dd>Network mask</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Bool - Returns if the address overlaps a network</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def address_is_in_network(addr, net):
    &#34;&#34;&#34;

    Address is in network.

    Parameters
    ----------
    addr: String
        Address - 10.0.0.20
    net: String
        Network - 10.0.0.0/24
    mask: String
        Network mask

    Returns
    -------
    Bool - Returns if the address overlaps a network

    &#34;&#34;&#34;
    return IPv4Network(addr).overlaps(IPv4Network(net))</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.cidr_match"><code class="name flex">
<span>def <span class="ident">cidr_match</span></span>(<span>ip_addr, cidr)</span>
</code></dt>
<dd>
<div class="desc"><p>Match cidr.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ip_addr</code></strong> :&ensp;<code>String</code></dt>
<dd>IP Address eg: 10.1.0.20</dd>
<dt><strong><code>cidr</code></strong> :&ensp;<code>String</code></dt>
<dd>cidr eg. 10.1.0.20/32</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cidr_match(ip_addr, cidr):
    &#34;&#34;&#34;

    Match cidr.

    Parameters
    ----------
    ip_addr: String
        IP Address eg: 10.1.0.20
    cidr: String
        cidr eg. 10.1.0.20/32

    Returns
    -------
    Bool

    &#34;&#34;&#34;
    subnet, mask = cidr.split(&#39;/&#39;)

    return (int(IPv4Address(ip_addr)) &amp; ~((1 &lt;&lt; (32 - int(mask))) - 1)) == \
        int(IPv4Address(subnet))</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.cidr_to_range"><code class="name flex">
<span>def <span class="ident">cidr_to_range</span></span>(<span>cdir)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Start and End Address of the IP range from CIDR.</p>
<p>Eg.[10.0.0.0/24] =&gt; 10.0.0.0 - 10.0.0.255</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cdir</code></strong> :&ensp;<code>String</code></dt>
<dd>cdir range</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong> :&ensp;<code>List</code> of <code>ip range</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cidr_to_range(cdir):
    &#34;&#34;&#34;

    Get the Start and End Address of the IP range from CIDR.

    Eg.[10.0.0.0/24] =&gt; 10.0.0.0 - 10.0.0.255

    Parameters
    ----------
    cdir: String
        cdir range

    Returns
    -------
    list: List of ip range

    &#34;&#34;&#34;
    r_ips = list(ip_network(cdir).hosts())
    ip_range = [str(x) for x in r_ips]

    return ip_range</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.cidr_to_subnet_and_subnetmask_address"><code class="name flex">
<span>def <span class="ident">cidr_to_subnet_and_subnetmask_address</span></span>(<span>cidr)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the subnet and subnetmast from a cidr.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cidr</code></strong> :&ensp;<code>String eg. '10.0.0.0/24'</code></dt>
<dd>cidr value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Dict</code></strong> :&ensp;<code>netmask and network_address</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cidr_to_subnet_and_subnetmask_address(cidr):
    &#34;&#34;&#34;

    Get the subnet and subnetmast from a cidr.

    Parameters
    ----------
    cidr: String eg. &#39;10.0.0.0/24&#39;
        cidr value

    Returns
    -------
    Dict: netmask and network_address

    &#34;&#34;&#34;
    network = IPv4Network(cidr)

    return {&#39;subnet_ip&#39;: str(network.network_address),
            &#39;subnet_mask&#39;: str(network.netmask)}</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.convert_yang_into_xml_file"><code class="name flex">
<span>def <span class="ident">convert_yang_into_xml_file</span></span>(<span>yang_filenames, xml_output_file: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert YANG files into one XML file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>yang_filenames</code></strong> :&ensp;<code>Array</code></dt>
<dd>It contains the list of YANG files (with full path name of
each files</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xml_output_file</code></strong> :&ensp;<code>String</code></dt>
<dd>Filename of the new YANG file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_yang_into_xml_file(yang_filenames, xml_output_file: str):
    &#34;&#34;&#34;
    Convert YANG files into one XML file.

    Parameters
    ----------
    yang_filenames: Array
            It contains the list of YANG files (with full path name of
            each files

    Returns
    -------
    xml_output_file: String
            Filename of the new YANG file

    &#34;&#34;&#34;
    # Get the directory where all PYANG files are present. We should run
    # pyang in this directory to be able to load other yang generic library
    # dependency present in the same directory.
    yang_path = os.path.dirname(yang_filenames[0])
    yang_files = &#39;&#39;
    for file in yang_filenames:
        yang_files = yang_files + &#39; &#39; + str(os.path.basename(file))

    pyang_command = &#39; cd &#34;&#39; + yang_path + \
        &#39;&#34;;  pyang -f sample-xml-skeleton &#39; + \
        &#39;--sample-xml-skeleton-doctype=config  -o &#39; + \
        xml_output_file + yang_files

    try:
        subprocess.check_output(pyang_command, shell=True,
                                stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as error_msg:
        return &#39;Error:&#39; + str(error_msg)

    return xml_output_file</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.get_ip_range"><code class="name flex">
<span>def <span class="ident">get_ip_range</span></span>(<span>start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a list of all IP addresses between $start and $end (inclusive).</p>
<p>For Ex. (1.1.1.1, 1.1.1.5) =&gt; [1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.1.4, 1.1.1.5]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>String</code></dt>
<dd>start of the range</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>String</code></dt>
<dd>end of the range</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong> :&ensp;<code>List</code> of <code>range</code> of <code>ips</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip_range(start, end):
    &#34;&#34;&#34;

    Generate a list of all IP addresses between $start and $end (inclusive).

    For Ex. (1.1.1.1, 1.1.1.5) =&gt; [1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.1.4, 1.1.1.5]

    Parameters
    ----------
    start: String
            start of the range
    end: String
            end of the range

    Returns
    -------
    list: List of range of ips

    &#34;&#34;&#34;
    ip_range = list(range(int(IPv4Address(start)), int(IPv4Address(end))))
    result = list(map(lambda x: str(IPv4Address(x)), ip_range))
    result.append(end)

    return result</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.is_cidr"><code class="name flex">
<span>def <span class="ident">is_cidr</span></span>(<span>addr)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a valid cidr.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>String</code></dt>
<dd>IP address</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong> :&ensp;<code>Valid cidr</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_cidr(addr):
    &#34;&#34;&#34;

    Check if a valid cidr.

    Parameters
    ----------
    addr: String
        IP address

    Returns
    -------
    bool: Valid cidr

    &#34;&#34;&#34;
    try:
        IPv4Address(addr)
    except AddressValueError:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.is_overlapping_cidr"><code class="name flex">
<span>def <span class="ident">is_overlapping_cidr</span></span>(<span>cidr1, cidr2)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if cidr1 overlaps cidr2.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cidr1</code></strong> :&ensp;<code>String</code></dt>
<dd>First cidr to compare</dd>
<dt><strong><code>cidr2</code></strong> :&ensp;<code>String</code></dt>
<dd>Second cidr to compare</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong> :&ensp;<code>Cidr overlaps</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_overlapping_cidr(cidr1, cidr2):
    &#34;&#34;&#34;

    Check if cidr1 overlaps cidr2.

    Parameters
    ---------
    cidr1: String
        First cidr to compare
    cidr2: String
        Second cidr to compare

    Returns
    -------
    bool: Cidr overlaps

    &#34;&#34;&#34;
    return IPv4Network(cidr1).overlaps(IPv4Network(cidr2))</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.log_to_process_file"><code class="name flex">
<span>def <span class="ident">log_to_process_file</span></span>(<span>service_id: str, log_message: str, process_id: str = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Write log string with ISO timestamp to process log file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>service_id</code></strong> :&ensp;<code>String</code></dt>
<dd>Service ID of current process</dd>
<dt><strong><code>log_message</code></strong> :&ensp;<code>String</code></dt>
<dd>Log text</dd>
<dt><strong><code>process_id</code></strong> :&ensp;<code>String</code></dt>
<dd>Process ID of current process</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool:</code></dt>
<dd>
<p>true:
log string has been written correctlly</p>
<p>false: log string has not been written correctlly or the
log file doesnt exist</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_to_process_file(service_id: str, log_message: str, process_id: str=None) -&gt; bool:
    &#34;&#34;&#34;

    Write log string with ISO timestamp to process log file.

    Parameters
    ----------
    service_id: String
                Service ID of current process
    log_message: String
                 Log text
    process_id: String
                Process ID of current process

    Returns
    -------
    bool:
        true:  log string has been written correctlly

        false: log string has not been written correctlly or the
                log file doesnt exist

    &#34;&#34;&#34;
    process_log_path = &#39;{}/process-{}.log&#39;.format(
        constants.PROCESS_LOGS_DIRECTORY, service_id)
    current_time = datetime.now().isoformat()
    if not process_id:
        log_string = &#39;{date}:{file}:DEBUG:{msg}\n&#39;.format(
            date=current_time, file=sys.argv[0].split(&#39;/&#39;)[-1], msg=log_message)
    else:
        log_string = &#39;{date}:{file}:|{process_id}|:DEBUG:{msg}\n&#39;.format(
            date=current_time, file=sys.argv[0].split(&#39;/&#39;)[-1], process_id=process_id, msg=log_message)
        if &#34;\n&#34; in log_message:
            log_string += &#39;{date}:{file}:|{process_id}--|\n&#39;.format(
            date=current_time, file=sys.argv[0].split(&#39;/&#39;)[-1], process_id=process_id)
    try:
        with open(process_log_path, &#39;a&#39;) as log_file:
            log_file.write(log_string)
    except IOError:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.netmask_to_cidr"><code class="name flex">
<span>def <span class="ident">netmask_to_cidr</span></span>(<span>netmask)</span>
</code></dt>
<dd>
<div class="desc"><p>Netmask to cidr.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>netmask</code></strong> :&ensp;<code>String</code></dt>
<dd>Netmask</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>cidr netmask</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def netmask_to_cidr(netmask):
    &#34;&#34;&#34;

    Netmask to cidr.

    Parameters
    ----------
    netmask: String
        Netmask

    Returns
    -------
    string: cidr netmask

    &#34;&#34;&#34;
    return sum([bin(int(x)).count(&#34;1&#34;) for x in netmask.split(&#34;.&#34;)])</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.obtain_file_lock"><code class="name flex">
<span>def <span class="ident">obtain_file_lock</span></span>(<span>lock_file_name, mode, process_param, sleep_time=60, timeout=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain lock file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lock_file_name</code></strong> :&ensp;<code>String</code></dt>
<dd>File name</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>String mode</code></dt>
<dd>File mode</dd>
<dt><strong><code>process_param</code></strong> :&ensp;<code>options PROCESSINSTANCEID, TASKID, EXECNUMBER</code></dt>
<dd>Process parameters</dd>
<dt><strong><code>sleep_time</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Time to wait until next try</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Integer</code></dt>
<dd>How much time (timeout * sleep_time) it will take to timeout</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>json</code></strong> :&ensp;<code>Result</code> of <code>the lock</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obtain_file_lock(lock_file_name, mode, process_param, sleep_time=60,
                     timeout=300):
    &#34;&#34;&#34;

    Obtain lock file.

    Parameters
    ----------
    lock_file_name: String
        File name
    mode: String mode
        File mode
    process_param: options PROCESSINSTANCEID, TASKID, EXECNUMBER
        Process parameters
    sleep_time: Integer
        Time to wait until next try
    timeout: Integer
        How much time (timeout * sleep_time) it will take to timeout

    Returns
    ------
    json: Result of the lock

    &#34;&#34;&#34;
    lock_file_path = &#39;{}/{}&#39;.format(constants.UBI_JENTREPRISE_DIRECTORY,
                                    lock_file_name)

    lock_obtained = False

    r_json = &#39;&#39;
    tries = 1
    while not lock_obtained and tries &lt; timeout:
        try:
            if os.path.exists(lock_file_path):
                with open(lock_file_path) as f_file:
                    file_content = f_file.read()
            else:
                f_lock_file = open(lock_file_path, mode)
                fcntl.flock(f_lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
                with open(lock_file_path, &#39;w+&#39;) as f_file:
                    f_file.write(&#39;Locked&#39;)
                lock_obtained = True
                fcntl.flock(f_lock_file, fcntl.LOCK_UN)
                continue

            if &#39;unlocked&#39; not in file_content.lower():
                raise io.BlockingIOError

            lock_obtained = True
        except io.BlockingIOError:
            tries += 1
            time.sleep(sleep_time)

    if not lock_obtained:
        r_json = MSA_API.process_content(
            constants.FAILED,
            &#39;Lock could not be obtained on the file {}&#39;.format(
                lock_file_name),
            process_param,
            True)
    else:
        r_json = MSA_API.process_content(
            constants.ENDED,
            &#39;Lock obtained on the file {}&#39;.format(lock_file_name),
            process_param,
            True)

    return r_json</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.release_file_lock"><code class="name flex">
<span>def <span class="ident">release_file_lock</span></span>(<span>lock_file_name, process_param, sleep_time=60, timeout=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Release lock file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lock_file_name</code></strong> :&ensp;<code>String</code></dt>
<dd>File name</dd>
<dt><strong><code>process_param</code></strong> :&ensp;<code>options PROCESSINSTANCEID, TASKID, EXECNUMBER</code></dt>
<dd>Process parameters</dd>
<dt><strong><code>sleep_time</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Time to wait until next try</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Integer</code></dt>
<dd>How much time (timeout * sleep_time) it will take to timeout</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>json</code></strong> :&ensp;<code>Result</code> of <code>the release</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release_file_lock(lock_file_name, process_param, sleep_time=60,
                      timeout=300):
    &#34;&#34;&#34;

    Release lock file.

    Parameters
    ----------
    lock_file_name: String
        File name
    process_param: options PROCESSINSTANCEID, TASKID, EXECNUMBER
        Process parameters
    sleep_time: Integer
        Time to wait until next try
    timeout: Integer
        How much time (timeout * sleep_time) it will take to timeout

    Returns
    ------
    json: Result of the release

    &#34;&#34;&#34;
    lock_file_path = &#39;{}/{}&#39;.format(constants.UBI_JENTREPRISE_DIRECTORY,
                                    lock_file_name)

    f_lock_file = open(lock_file_path)

    r_json = &#39;&#39;
    tries = 1

    while tries &lt; timeout:
        try:
            fcntl.flock(f_lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
            with open(lock_file_path, &#39;w+&#39;) as f_file:
                f_file.write(&#39;Unlocked&#39;)
            fcntl.flock(f_lock_file, fcntl.LOCK_UN)
            break

        except io.BlockingIOError:
            tries += 1
            time.sleep(sleep_time)

    if tries &gt;= timeout:
        r_json = MSA_API.process_content(
            constants.FAILED,
            &#39;Lock could not be released on the file {}&#39;.format(
                lock_file_name), process_param, True)
    else:
        r_json = MSA_API.process_content(
            constants.ENDED,
            &#39;Lock released on the file {}&#39;.format(lock_file_name),
            process_param, True)

    return r_json</code></pre>
</details>
</dd>
<dt id="msa_sdk.util.update_asynchronous_task_details"><code class="name flex">
<span>def <span class="ident">update_asynchronous_task_details</span></span>(<span>details: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Update Asynchronous Task details.</p>
<p>Print task details during Process execution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>detail</code></strong> :&ensp;<code>String</code></dt>
<dd>The message to display in msa-ui</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>object</code></strong> :&ensp;<code>Orchestration</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_asynchronous_task_details(details: str):
    &#34;&#34;&#34;

    Update Asynchronous Task details.

    Print task details during Process execution.

    Parameters
    ----------
    detail: String
            The message to display in msa-ui

    Returns
    -------
    object: Orchestration

    &#34;&#34;&#34;
    context = Variables.task_call()
    process_instance_id = context[&#39;PROCESSINSTANCEID&#39;]
    task_id = context[&#39;TASKID&#39;]
    exec_number = context[&#39;EXECNUMBER&#39;]
    orch = Orchestration(None)
    orch.update_asynchronous_task_details(process_instance_id, task_id,
                                          exec_number, details)
    return orch</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="msa_sdk" href="index.html">msa_sdk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="msa_sdk.util.address_is_in_network" href="#msa_sdk.util.address_is_in_network">address_is_in_network</a></code></li>
<li><code><a title="msa_sdk.util.cidr_match" href="#msa_sdk.util.cidr_match">cidr_match</a></code></li>
<li><code><a title="msa_sdk.util.cidr_to_range" href="#msa_sdk.util.cidr_to_range">cidr_to_range</a></code></li>
<li><code><a title="msa_sdk.util.cidr_to_subnet_and_subnetmask_address" href="#msa_sdk.util.cidr_to_subnet_and_subnetmask_address">cidr_to_subnet_and_subnetmask_address</a></code></li>
<li><code><a title="msa_sdk.util.convert_yang_into_xml_file" href="#msa_sdk.util.convert_yang_into_xml_file">convert_yang_into_xml_file</a></code></li>
<li><code><a title="msa_sdk.util.get_ip_range" href="#msa_sdk.util.get_ip_range">get_ip_range</a></code></li>
<li><code><a title="msa_sdk.util.is_cidr" href="#msa_sdk.util.is_cidr">is_cidr</a></code></li>
<li><code><a title="msa_sdk.util.is_overlapping_cidr" href="#msa_sdk.util.is_overlapping_cidr">is_overlapping_cidr</a></code></li>
<li><code><a title="msa_sdk.util.log_to_process_file" href="#msa_sdk.util.log_to_process_file">log_to_process_file</a></code></li>
<li><code><a title="msa_sdk.util.netmask_to_cidr" href="#msa_sdk.util.netmask_to_cidr">netmask_to_cidr</a></code></li>
<li><code><a title="msa_sdk.util.obtain_file_lock" href="#msa_sdk.util.obtain_file_lock">obtain_file_lock</a></code></li>
<li><code><a title="msa_sdk.util.release_file_lock" href="#msa_sdk.util.release_file_lock">release_file_lock</a></code></li>
<li><code><a title="msa_sdk.util.update_asynchronous_task_details" href="#msa_sdk.util.update_asynchronous_task_details">update_asynchronous_task_details</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>